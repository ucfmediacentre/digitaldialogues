// VOD// VOD// VOD// VOD//4.5 SDK can be found at http://download.macromedia.com/pub/flex/sdk/flex_sdk_4.5.zip//package{	import com.wowza.WMSMediaFactory;	import com.wowza.WMSNetLoader;		import flash.display.LoaderInfo;	import flash.display.StageDisplayState;	import flash.events.Event;	import flash.events.FullScreenEvent;	import flash.events.IOErrorEvent;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.external.ExternalInterface;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.net.Responder;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.system.Capabilities;	import flash.system.Security;	import flash.utils.Timer;	import flash.utils.setTimeout;		import mx.containers.Canvas;	import mx.containers.Form;	import mx.controls.Alert;	import mx.controls.Button;	import mx.controls.HRule;	import mx.controls.Text;	import mx.controls.TextInput;	import mx.controls.sliderClasses.Slider;	import mx.events.DragEvent;	import mx.events.FlexEvent;	import mx.events.SliderEvent;		import spark.components.Application;	import spark.components.BorderContainer;	import spark.components.Image;	import spark.components.Label;	import spark.components.TextArea;	import spark.components.VGroup;		import org.osmf.containers.MediaContainer;	import org.osmf.elements.VideoElement;	import org.osmf.events.LoadEvent;	import org.osmf.events.MediaElementEvent;	import org.osmf.events.MediaErrorEvent;	import org.osmf.events.MediaPlayerCapabilityChangeEvent;	import org.osmf.events.PlayEvent;	import org.osmf.events.TimeEvent;	import org.osmf.media.DefaultMediaFactory;	import org.osmf.media.MediaElement;	import org.osmf.media.MediaFactoryItem;	import org.osmf.media.MediaPlayer;	import org.osmf.media.URLResource;	import org.osmf.net.DynamicStreamingItem;	import org.osmf.net.DynamicStreamingResource;	import org.osmf.net.NetLoader;	import org.osmf.net.metrics.MetricFactory;	import org.osmf.samples.MediaContainerUIComponent;	import org.osmf.traits.PlayState;	import org.osmf.utils.OSMFSettings;	import org.osmf.utils.Version;
		public class Player extends Application	{		Security.LOCAL_TRUSTED;				[Embed (source="assets/fullscreen.png")]		public static const FULLSCREEN:Class;		[Embed (source="assets/normalscreen.png")]		public static const NORMALSCREEN:Class;		[Embed (source="assets/pause.png")]		public static const PAUSE:Class;		[Embed (source="assets/play.png")]		public static const PLAY:Class;		[Embed (source="assets/volume_off.png")]		public static const VOLUME_OFF:Class;		[Embed (source="assets/volume_on.png")]		public static const VOLUME_ON:Class;		[Embed (source="assets/rewind.png")]		public static const REWIND:Class;						[Bindable]		public var isConnected:Boolean = false;				private var mediaElement:MediaElement;		private var factory:WMSMediaFactory = new WMSMediaFactory();		private var player:MediaPlayer = new MediaPlayer();		private var isScrubbing:Boolean = false;		private var fullscreenCapable:Boolean = false;		private var hardwareScaleCapable:Boolean = false;		private var saveVideoObjX:Number;		private var saveVideoObjY:Number;		private var saveVideoObjW:Number;		private var saveVideoObjH:Number;		private var saveStageW:Number;		private var saveStageH:Number;		private var adjVideoObjW:Number;		private var adjVideoObjH:Number;		private var streamName:String;		private var PlayVersionMin:Boolean;		public var prompt:Text;		public var warn:Text;		[Bindable]		public var connectStr:TextInput;		public var playerVersion:Text;		public var videoContainer:MediaContainerUIComponent;		public var connectButton:Button;		public var doPlay:Image;		public var doMute:Image;		public var seekBar:Slider;		public var controlGroup:VGroup;		public var doRewind:Image;		public var doFullscreen:Image;		private var dynResource:DynamicStreamingResource;		public var streamForm:Form		private var muted:Boolean=false;		private var fullscreen:Boolean=false;		public var volumeContainer:BorderContainer;		public var sliderTrack:HRule;		public var sliderBug:Image;		private var knobWidth:Number;		private var trackWidth:Number;		private var trackX:Number;		private var boundsWidth:Number;		private var boundsRect:Rectangle;		private var draggingBug:Boolean=false;		private var sliderBugY:Number;		public var currentBitrate:Label;		private var netLoader:WMSNetLoader = new WMSNetLoader();		public function Player()		{			super();			this.addEventListener(FlexEvent.APPLICATION_COMPLETE,init);		}				private function init(event:FlexEvent):void		{				stage.align="TL";			stage.scaleMode="showAll";			stage.color=0;			doFullscreen.addEventListener(MouseEvent.CLICK,enterFullscreen);			doMute.addEventListener(MouseEvent.CLICK, muteSound);			stage.addEventListener(FullScreenEvent.FULL_SCREEN, enterLeaveFullscreen);			connectButton.addEventListener(MouseEvent.CLICK,connect);			doPlay.addEventListener(MouseEvent.CLICK,togglePlayPause);			doRewind.addEventListener(MouseEvent.CLICK,rewind);			knobWidth=sliderBug.width;			trackWidth=sliderTrack.width;			trackX=sliderTrack.x;			boundsWidth=trackWidth-knobWidth;			sliderBugY=sliderBug.y;			boundsRect=new Rectangle(trackX,sliderBugY,boundsWidth,0);						seekBar.addEventListener(SliderEvent.CHANGE,movieSeek);			seekBar.addEventListener(MouseEvent.MOUSE_DOWN, function(event:MouseEvent):void{				isScrubbing=true;			});			this.addEventListener(MouseEvent.MOUSE_UP, function(event:MouseEvent):void{				isScrubbing=false;			});				seekBar.maximum = 0;			sliderBug.addEventListener(MouseEvent.MOUSE_DOWN, sliderBugMouseDown);			sliderBug.addEventListener(MouseEvent.MOUSE_UP, sliderBugMouseUp);			addEventListener(MouseEvent.MOUSE_UP, sliderBugMouseUp);			volumeContainer.addEventListener(MouseEvent.CLICK, sliderBugClick);			sliderTrack.addEventListener(MouseEvent.CLICK, sliderBugClick);			addEventListener(MouseEvent.MOUSE_MOVE, sliderBugOver);						try {				connectStr.text = ExternalInterface.call("getVODHTTPStream");				ExternalInterface.addCallback("playerStop", stopAll);				ExternalInterface.addCallback("setStream", setStream);			}			catch(e:Error) {				prompt.text=""+e;			}			if(connectStr.text == null || connectStr.text=="")			{				connectStr.text = "http://localhost:1935/vod/mp4:sample.mp4/manifest.f4m";								}						OSMFSettings.enableStageVideo = true;			checkVersion();						// *********************** stream examples ******************//			// http://localhost:1935/vod/mp4:sample.mp4/manifest.f4m			// http://localhost:1935/vod/smil:streamNames.smil/manifest.f4m (server-side smil)			// rtmp://localhost:1935/vod/mp4:sample.mp4			// rtmp://localhost:1935/vod/streamNames.xml (Dynamic Streams)							videoContainer.container = new MediaContainer();			PlayVersionMin = testVersion(10, 1, 0, 0);							playerVersion.text = Capabilities.version + " (Flash-OSMF " + org.osmf.utils.Version.version + ")";				saveStageW = stage.width;			saveStageH = stage.height;			currentBitrate.text="";			saveVideoObjX = videoContainer.x;			saveVideoObjY = videoContainer.y;			saveVideoObjW = videoContainer.width;			saveVideoObjH = videoContainer.height;						var updateTimer:Timer = new Timer(500,0);			updateTimer.addEventListener(TimerEvent.TIMER, updateBitrate);			updateTimer.start();		}				public function setStream(stream:String):void		{			connectStr.text = stream;		}				private function sliderBugMouseDown(event:MouseEvent):void		{			if(!isConnected) {				return			}			sliderBug.y=sliderBugY;			sliderBug.startDrag(false, boundsRect);			draggingBug=true;			player.volume = sliderBug.x/sliderTrack.width;			muted = false;			doMute.source=VOLUME_ON;		}		private function sliderBugOver(event:MouseEvent):void		{			sliderBug.y=sliderBugY;			if(!isConnected || draggingBug==false ) {				return			}			player.volume = sliderBug.x/sliderTrack.width;			muted = false;			doMute.source=VOLUME_ON;		}		private function sliderBugMouseUp(event:MouseEvent):void		{			if(!isConnected) {				return			}			sliderBug.stopDrag();			draggingBug=false;		}				private function sliderBugClick(event:MouseEvent):void		{			if(!isConnected) {				return			}			sliderBug.x = event.localX;			player.volume=sliderBug.x/sliderTrack.width;		}				private function muteSound(event:MouseEvent):void		{			if(!isConnected) {				return;			}			if(muted) {				muted = false;				doMute.source=VOLUME_ON;				player.volume=sliderBug.x/sliderTrack.width;			} else {				muted = true;				doMute.source=VOLUME_OFF;				player.volume=0;			}		}					private function connect(event:MouseEvent):void // Play button (connectButton)		{				if (connectButton.label == "Stop")			{				doPlay.source=PLAY;				stopAll();				return;			}			var ok:Boolean = checkVersion();			if (!ok)			{				stopAll();				return;			}						if (connectStr.text.toLowerCase().indexOf("rtmp://")>-1 && connectStr.text.toLowerCase().indexOf(".xml")>-1)				streamName = connectStr.text.substring(connectStr.text.lastIndexOf("/")+1, connectStr.text.length);			if (streamName==null) 			{				loadStream();			}			else if (streamName.toLowerCase().indexOf(".xml") > 0)			{					loadVector(streamName); // load Dynamic stream items			}		}				private function loadStream():void		{				prompt.text = "";			mediaElement = factory.createMediaElement(new URLResource(connectStr.text));			if (dynResource != null)				mediaElement.resource=dynResource;			player = new MediaPlayer();			player.media = mediaElement;			videoContainer.container.addMediaElement(mediaElement);			player.addEventListener(TimeEvent.CURRENT_TIME_CHANGE, videoTimeChange);			isConnected = true;						mediaElement.addEventListener(MediaErrorEvent.MEDIA_ERROR,function(event:MediaErrorEvent):void			{				trace("Media Error: " + event.error.detail);				stopAll();				if(event.error != null && event.error.detail != null && event.error.detail.indexOf("Error #2032") >= 0) {					prompt.text = "Source stream or file could not be found or access was denied.";				} else {					prompt.text = event.error.message + " " + event.error.detail;				}								return;			});						player.addEventListener(PlayEvent.PLAY_STATE_CHANGE, function(event:PlayEvent):void			{				trace("Play event: " + event.playState);				if (event.playState == PlayState.STOPPED)						stopAll();			});						player.addEventListener(MediaPlayerCapabilityChangeEvent.CAN_PLAY_CHANGE, function(event:MediaPlayerCapabilityChangeEvent):void			{				isConnected = event.enabled;				if(isConnected) {					if(muted) {						player.volume=0;					} else {						player.volume=sliderBug.x/sliderTrack.width;					}					prompt.text="Playing"				}			});						player.autoPlay = true;			connectButton.label  = "Stop";			doPlay.source=PAUSE;		}					private function videoTimeChange(event:TimeEvent):void		{			if (isScrubbing)				return;						seekBar.value = event.time;						if (seekBar.maximum == 0 && player.duration > 0)			{				seekBar.maximum = player.duration + 4;			}		}				private function movieSeek(event:SliderEvent):void		{			if (player.canSeek)				player.seek(event.value);		}				private function rewind(event:MouseEvent):void		{			if (player.canSeek)				player.seek(0);				seekBar.value = 0;		}				private function updateBitrate(event:TimerEvent):void		{			if(player !=null && factory.httpStreamingNetLoader != null && factory.httpStreamingNetLoader.getNetStream() != null) {				currentBitrate.text="Current bitrate: "+ Math.round((factory.httpStreamingNetLoader.getNetStream().info.playbackBytesPerSecond*8)/1000)+"kbps";			} else {				currentBitrate.text="";			}		}				private function togglePlayPause(event:MouseEvent):void		{			if(!isConnected) {				connect(event);				prompt.text="Playing"				doPlay.source=PAUSE;				return;			}			if (player.playing)			{				prompt.text="Paused"				player.pause();				doPlay.source=PLAY;			}			else			{				prompt.text="Playing"				player.play();				doPlay.source=PAUSE;			}		}				private function stopAll():void		{				if (player!=null)			{				player.removeEventListener(TimeEvent.CURRENT_TIME_CHANGE, videoTimeChange);				if (player.playing)					player.stop();			}						seekBar.value = 0;			seekBar.maximum = 0;			isConnected = false;						if (mediaElement != null)				videoContainer.container.removeMediaElement(mediaElement);						mediaElement = null;			connectButton.label = "Start";			player = null;			prompt.text = "";						dynResource = null;		}				private function loadVector(streamName:String):void		{			var url:String = connectStr.text;						if (url.indexOf("rtmp://") != 0)			{				loadStream();				return;			}						var loader:URLLoader=new URLLoader();			loader.addEventListener(Event.COMPLETE,xmlHandler);			loader.addEventListener(IOErrorEvent.IO_ERROR,xmlIOErrorHandler)									var request:URLRequest=new URLRequest();			var requestURL:String = streamName;			request.url = requestURL;						loader.load(request)		}				private function xmlHandler(event:Event):void		{			var streamsVector:Vector.<DynamicStreamingItem> = new Vector.<DynamicStreamingItem>();			var streamNames:XML;				var loader:URLLoader=URLLoader(event.target);			streamNames = new XML(loader.data);						var videos:XMLList = streamNames..video;						for (var i:int=0; i<videos.length(); i++)			{				var video:XML = videos[i];				var bitrate:String = video.attribute("system-bitrate");				var item:DynamicStreamingItem = new DynamicStreamingItem(video.@src,Number(bitrate), video.@width, video.@height);				streamsVector.push(item);			}			if (videos.length()>0)			{				dynResource = new DynamicStreamingResource(connectStr.text);								dynResource.streamItems = streamsVector;			}			loadStream();		}				private function enterLeaveFullscreen(event:FullScreenEvent):void		{			trace("enterLeaveFullscreen: "+ event.fullScreen);			if (!event.fullScreen)			{				// reset back to original state				//this.setStyle("backgroundColor","#FFFFFF");				leaveFullscreen();			}		}				private function leaveFullscreen():void		{			stage.scaleMode = "showAll";			stage.displayState = StageDisplayState.NORMAL; 			videoContainer.width = saveVideoObjW;			videoContainer.height = saveVideoObjH;			videoContainer.x = saveVideoObjX;			videoContainer.y = saveVideoObjY;			doFullscreen.source=FULLSCREEN;			seekBar.visible=true;			controlGroup.visible=true;			streamForm.visible=true;		}				private function enterFullscreen(event:MouseEvent):void		{			if(fullscreen) {				doFullscreen.source=FULLSCREEN;				leaveFullscreen();				fullscreen=false;				return;			}			trace("enterFullscreen: "+hardwareScaleCapable);			stage.displayState = StageDisplayState.FULL_SCREEN;			doFullscreen.source=NORMALSCREEN;			fullscreen=true;			streamForm.visible = false;			seekBar.visible=false;			controlGroup.visible=false;						if (hardwareScaleCapable)			{				var topLeft:Point= videoContainer.localToGlobal(new Point(0,0));				var bottomR:Point= videoContainer.localToGlobal(new Point(videoContainer.x+videoContainer.width, videoContainer.y+videoContainer.height));				stage["fullScreenSourceRect"] = new Rectangle(					topLeft.x, topLeft.y, 					bottomR.x, bottomR.y);			}			else			{				stage.scaleMode = "showAll";								var videoAspectRatio:Number = videoContainer.width/videoContainer.height;				var stageAspectRatio:Number = saveStageW/saveStageH;				var screenAspectRatio:Number = Capabilities.screenResolutionX/Capabilities.screenResolutionY;								// calculate the width and height of the scaled stage				var stageObjW:Number = saveStageW;				var stageObjH:Number = saveStageH;				if (stageAspectRatio > screenAspectRatio)					stageObjW = saveStageH*screenAspectRatio;				else					stageObjH = saveStageW/screenAspectRatio;								// calculate the width and height of the video frame scaled against the new stage size				var fsvideoContainerW:Number = stageObjW;				var fsvideoContainerH:Number = stageObjH;								if (videoAspectRatio > screenAspectRatio)					fsvideoContainerH = stageObjW/videoAspectRatio;							else					fsvideoContainerW = stageObjH*videoAspectRatio;				// scale the video object				videoContainer.width = fsvideoContainerW;				videoContainer.height = fsvideoContainerH;			}		}				private function xmlIOErrorHandler(event:IOErrorEvent):void		{			trace("XML IO Error: " + event.target);			prompt.text = "XML IO Error: " + event.text;			}				private function checkVersion():Boolean		{			PlayVersionMin = testVersion(10, 1, 0, 0);			hardwareScaleCapable = testVersion(9, 0, 60, 0);			if (!PlayVersionMin && connectStr.text.indexOf(".f4m") > 0)			{				prompt.text = "Sanjose Streaming not support in this Flash version.";				return false;			}			else			{				prompt.text="";				return true;			}		}				private function testVersion(v0:Number, v1:Number, v2:Number, v3:Number):Boolean		{			var version:String = Capabilities.version;			var index:Number = version.indexOf(" ");			version = version.substr(index+1);			var verParts:Array = version.split(",");						var i:Number;						var ret:Boolean = true;			while(true)			{				if (Number(verParts[0]) < v0)				{					ret = false;					break;				}				else if (Number(verParts[0]) > v0)					break;								if (Number(verParts[1]) < v1)				{					ret = false;					break;				}				else if (Number(verParts[1]) > v1)					break;								if (Number(verParts[2]) < v2)				{					ret = false;					break;				}				else if (Number(verParts[2]) > v2)					break;								if (Number(verParts[3]) < v3)				{					ret = false;					break;				}				break;			}			trace("testVersion: "+Capabilities.version+">="+v0+","+v1+","+v2+","+v3+": "+ret);				return ret;		}	}}